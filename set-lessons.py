

# наборы - set

# этот тип очень мощный и полезный инструмент в Python

# наборы - это неупорядоченные последовательности уникальных элементов

# наборы - содержат только уникальные элементы

# наборы - изменять наборы можно, но нельзя изменять элементы

# в наборах обычно сохраняют уникальные/однотипные элементы

# структура и синтаксис

# создание набора

my_fruits = {"apple", "banana", "cherry"}

posts_ids = {1, 2, 3, 4, 5}

users_info = {"name", "email", "phone"} # в наборе могут быть обекты разных типов данных

print(my_fruits)
print(posts_ids)
print(users_info)

print(type(my_fruits))

print('\n') # пустая строка

# при создании набора если в нем будет лежать несколько одинаковых элементов, то они будут удалены/ не будут отображаться
# но никаких ошибок не будет выводиться в консоль

# пример

posts_ids = {1, 2, 3, 4, 5, 1, 2, 3, 4, 5} # в наборе не может быть одинаковых элементов,только уникальные

print(posts_ids)

print('\n') # пустая строка

# таким образом я могу быстро найти уникальные данные в моем наборе не видя в них дубликатов

# порядок в наборе не важен и не имеет значения
# два одинаковых набора с разной последовательностью элементов будет иметь одинаковый результат - True

# пример

my_fruits = {"apple", "banana", "cherry"}
my_fruits_2 = {"banana", "cherry", "apple"}

print(my_fruits == my_fruits_2)

# проверить длину набора можно так же как и в списках и кортежах с помощью len() НО ИНДЕКСОВ В НАБОРАХ НЕТ


# практика

print('\n') # пустая строка

# изменяемые обьекты в наборах

# удалять элементы из набора можно с помощью метода remove()


# my_set = { 10, 10, 5, 15, 15} # в наборе не может быть одинаковых элементов,только уникальные
my_set = { (10, 10), 5, 15, 15} # можно добавить кортеж в набор но не список

print(my_set)

# чтобы вызвать пустой набор мы используем set()

my_set = set()

print(type(my_set))

print('\n') # пустая строка

# в наборе не могу присутствовать изменяемые обьекты

# методы наборов

# add() - добавляет элемент в набор
# remove() - удаляет элемент из набора
# clear() - очищает набор
# copy() - копирует набор
# pop() - удаляет случайный элемент из набора
# union() - объединяет наборы
# update() - обновляет набор
# difference() - возвращает различия между наборами
# intersection() - возвращает пересечение наборов
# isdisjoint() - возвращает True если нет одинаковых элементов в наборах
# issubset() - возвращает True если один набор является подмножеством другого
# issuperset() - возвращает True если один набор является надмножеством другого
# discard() - удаляет элемент из набора если он присутствует

# add - добавляет элемент в набор

photo_sizes = {'1920x1080', '800x600'} # создаем набор

photo_sizes.add('1024x768') # добавляем элемент в набор

print(photo_sizes) # {'1920x1080', '800x600', '1024x768'}

print('\n') # пустая строка

# union - объединяет наборы

photo_sizes = {'1920x1080', '800x600'} # создаем набор
other_sizes = {'1024x768', '1280x720', '800x600'} # создаем набор

all_sizes = photo_sizes.union(other_sizes) # объединяем наборы в один, в данном случае будет игнорировать
# повторный элемент

print(all_sizes) # {'1920x1080', '800x600', '1024x768', '1280x720'}

print('\n') # пустая строка

# intersection - возвращает пересечение наборов

photo_s = {'1920x1080', '800x600'} # создаем набор
other_s = {'1024x768', '1280x720', '800x600'} # создаем набор

common_sizes = photo_s.intersection(other_s) # возвращает пересечение наборов в данном случае будет игнорировать
# повторные элементы

print(common_sizes) # {'800x600'} результатом вывода будет новый набор с одинаковыми элементами которые пересекаются

print('\n') # пустая строка

# issubset - возвращает True если один набор является подмножеством другого

nums = {10, 5, 35} # создаем набор
other_nums = {20, 5 , 12, 10, 35} # создаем набор, считается супермножеством,
# так как содержит все элементы первого набора

res = nums.issubset(other_nums) # возвращает True если один набор является подмножеством другого

print(res) # True - так как все элементы первого набора содержатся во втором наборе

print('\n') # пустая строка

# практика методов наборов

my_set = {'abc', 'd', 'f', 'y'} # создаем набор
other_set = {'a', 'f', 'd'} # создаем набор

print(my_set.intersection('abcd')) #
print(other_set.intersection(my_set)) # {'d', 'f'} - возвращает пересечение наборов


print('\n') # пустая строка

# практические задания

# 1. Cоздайте набор с несколькими элементами типа int

practice_set = {1, 2, 3, 4, 5}

# 2. Добавьте в набор еще один элемент

practice_set.add(6)

# 3. Создайте еще один набор с несколькими элементами, причем некоторые должны быть такими же как в первом наборе

second_practice_set = {3, 4, 5, 10, 22}

# 4. Найдите общие элементы в двух наборах и поместите их в новый набор

practice_set.intersection(second_practice_set)
all_practice_set = practice_set.intersection(second_practice_set)

# 5. Конвертируйте результирующий набор в список и выведите список в терминал


list_practice = list(all_practice_set)

print(list_practice)


# заметка

# наборы являются не упорядоченными последовательностями уникальных элементов. Т.е добавление в набор элемента
# не гарантирует что он будет добавлен в конец набора. Поэтому нельзя обратиться к элементу набора по индексу