

# pyton не выполняет неявную конвертацию типов данных

# встроенные функции для явного преобразования типов данных

# int() - преобразование в целое число
# float() - преобразование в число с плавающей точкой
# str() - преобразование в строку
# tuple() - преобразование в кортеж
# list() - преобразование в список
# set() - преобразование в множество
# dict() - преобразование в словарь

# примеры

# '10' + 20 # ошибка, так как нельзя складывать строку и число
#
# 5 + '10' # ошибка, так как нельзя складывать строку и число

#  методы класса объекта

# int_number = 10
# float_number = 10.5
#
# print(int_number + float_number) # 20.5 - результат float - преобразование int в float из-за неявного преобразования __add__

# магические методы класса объекта - перегрузка операторов которые позволяют изменить поведение операторов не изменяя их

# __add__ - перегрузка оператора сложения
# __radd__ - перегрузка оператора сложения справа
# __sub__ - перегрузка оператора вычитания
# __mul__ - перегрузка оператора умножения
# __truediv__ - перегрузка оператора деления
# __floordiv__ - перегрузка оператора целочисленного деления
# __mod__ - перегрузка оператора остатка от деления
# __pow__ - перегрузка оператора возведения в степень


int_num = 50
float_num = 7.5

# print(int_num * float_num) # 375.0 - результат float - преобразование int в float из-за неявного преобразования __mul_

print(int_num.__mul__(float_num)) # нельзя использовать так как __mul__ принимает один аргумент NotImplemented

print(float_num.__rmul__(int_num)) # 375.0


# магические методы - это внутренние методы классов и они обычно не вызываются явно/напрямую

# примеры

# __add__() - сложение
# __sub__() - вычитание
# __mul__() - умножение
# __truediv__() - деление
# __eq__() - равенство
# __and__() - логическое И


# примеры

print(bool) # <class 'bool'> - тип данных
print(bool(10)) # True
print(dir(bool)) # список методов класса bool
print(bool.__doc__) # bool(x) -> bool - возвращает True или False в зависимости от значения x